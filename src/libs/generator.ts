import { core } from '@salesforce/command';
import { OutputFlags } from '@oclif/parser';
import { join } from 'path';
import { Org, UX } from '@salesforce/core';
import { PicklistEntry } from "jsforce";


const header = `
/**
 * DO NOT MODIFY THIS FILE!
 *
 * This file is generated by the salesforce-to-types plugin and
 * may be regenerated in the future. It is recommended to make
 * changes to that plugin then regenerate these files.
 *
 */
`.trim();

const sobject = `${header}

import { ID, Attribute } from './sobject-field-types';

export type SObjectAttribute<TString> = SObject & Attribute<TString>;
export interface SObject {
  Id: ID;
}
`;

const constructor = (className) => `
  constructor(data: Partial<${className}> = {}) {
    super();
    super.setValues(data);
  }
`;


const sobjectFieldTypes = `${header}

export type ID = string;
export type DateString = string | null;
export type PhoneString = string;
export type PercentString = string | number;
export type Attribute<TString> = { attributes: { type: TString } }
export type ChildRecords<T, TString> = { records: Array<Partial<T> & Attribute<TString>> };
\/\/ export type RecordType = { Id: string; Name: string; DeveloperName: string; };
`;

export class Generator {
  flags: OutputFlags<any>;
  createdFiles: Array<String> = [];
  globalPicklists: {[picklistName: string]: PicklistEntry[]} = {};
  unmappedChildRelationships: Set<String>;
  org: Org
  ux: UX

  constructor(params: { org, flags, createdFiles?, ux }) {
    this.org = params.org;
    this.ux = params.ux;
    this.flags = params.flags;
    this.createdFiles = params.createdFiles || this.createdFiles;
    this.unmappedChildRelationships = new Set<String>();
  }


  public async generate() {
    await this.createBaseSObjectType();
    await this.createSalesforceFieldTypes();
    if (this.flags.sobject && this.flags.config) {
      process.stderr.write(`Please provide only -s or -c, not both`);
    } else if (this.flags.sobject) {
      await this.generateSObject();
    } else if (this.flags.config) {
      await this.generateSObjectsConfig()
    } else {
      process.stderr.write(`Please provide a -s or -c`);
    }
    return {createdFiles: this.createdFiles || []}
  }

  private async createBaseSObjectType() {
    const dir = await core.fs.readdir(this.flags.outputdir);
    const filePath = join(this.flags.outputdir, 'sobject.ts');
    await core.fs.writeFile(filePath, sobject);
    this.createdFiles.push(filePath);
  }

  private async createSalesforceFieldTypes() {
    const dir = await core.fs.readdir(this.flags.outputdir);
    const filePath = join(this.flags.outputdir, 'sobject-field-types.ts');
    await core.fs.writeFile(filePath, sobjectFieldTypes);
    this.createdFiles.push(filePath);
    return
  }

  generateSObjectTypeContents = async (objectName: string, sObjectsConfigs?: SobjectConfigurations, globalPicklistFields: string[] = []) => {
    let connection = this.org.getConnection();
    const describe = await connection.describe(objectName);
    const sObjects = Object.keys(sObjectsConfigs);
    const sObjectConf = sObjectsConfigs[objectName];
    let typeContents = '\n\n';
    const picklists: {[picklistName: string]: PicklistEntry[]} = {};

    const isFieldIgnored = (fieldName) => sObjectConf.fields && !sObjectConf.fields.includes(fieldName);
    const isSObjectOwnField = (fieldName) => describe.fields.map(field => field.name).includes(fieldName);

    const soupLocalFields = sObjectConf.fields
      .filter(field => !isSObjectOwnField(field))
      .map(f => this.formatFieldName(f));

    const relatedObjectAndLocalProperties = soupLocalFields
      .map(field => field.split('.')[0])
      .filter((val, index, arr) => arr.indexOf(val) === index);

    typeContents += `export class ${objectName} extends SObjectBase<'${objectName}'> implements LayerObject {`;

    typeContents += `\n  static readonly sObjectSyncDownFields = [${sObjectConf.fields.map(f => `'${f}'`).join(', ')}] as const;`;
    typeContents += `\n  static readonly sObjectOwnFields = [${sObjectConf.fields.filter(f => isSObjectOwnField(f)).map(f => `'${f}'`).join(', ')}] as const;`;
    typeContents += `\n  static readonly sObjectLocalFields = [${relatedObjectAndLocalProperties.map(f => `'${f}'`).join(', ')}] as const;\n`;

    // const specialChildrenToMapClone = Array.from(specialChildrenToMap || []);
    describe.fields.forEach(field => {
      if (field['name'] == 'Id' || isFieldIgnored(field['name']) ) {
        return;
      }

      let typeName: string;
      switch (field['type']) {
        case 'boolean':
          typeName = 'boolean';
          break;
        case 'int':
        case 'double':
        case 'currency':
          typeName = 'number';
          break;
        case 'date':
        case 'datetime':
          typeName = 'DateString';
          break;
        case 'phone':
          typeName = 'PhoneString';
          break;
        case 'string':
        case 'textarea':
          typeName = 'string';
          break;
        case 'reference':
          typeName = 'ID';
          break;
        case 'percent':
          typeName = 'PercentString';
          break;
        default:
          typeName = `string /* ${field['type']} */`;
      }

      if (field['type'] == 'picklist' && field.picklistValues.length) {
        const isCreateEnum = sObjectConf.picklistFields && sObjectConf.picklistFields.length && sObjectConf.picklistFields.includes(field.name);
        const isCreateGlobalEnum = globalPicklistFields.length && globalPicklistFields.includes(field.name);

        if(isCreateGlobalEnum && !this.globalPicklists.hasOwnProperty(field.name)) { // Add and use first picklist value
          this.globalPicklists[field.name] = field.picklistValues;
        }

        if(isCreateEnum) {
          typeName = objectName + field.name;
          picklists[typeName] = field.picklistValues;
        } else if(isCreateGlobalEnum) {
          typeName = field.name || typeName;
        } else {
          typeName = field.picklistValues.map(p => `\`${p.value}\``).join(' | ')
        }
      }

      typeContents += `\n  ${field['name']}: ${typeName};`;

      if (field['calculated']) {
        typeContents += ` // calculated`;
      }

      // REFERENCES
      // if (field['type'] == 'reference') {
      //   let refTypeName;
      //   field.referenceTo.forEach(r => {
      //     if (sObjects && sObjects.find(f => f === r)) {
      //       //add it if its in our list
      //       refTypeName = refTypeName ? `${refTypeName} | ${r}` : r
      //     }
      //   });
      //   if (refTypeName) {
      //     typeContents += `\n  ${field['relationshipName']}: ${refTypeName};`;
      //   }
      // }
    });

    if(soupLocalFields.length) {
      typeContents += this.generateSoupLocalFields(soupLocalFields);
    }

    //child relationships
    // describe.childRelationships.forEach(child => {
    //   const childSObject = child['childSObject'];
    //   const childRelationshipName = child['relationshipName'];
    //   if (sObjects && sObjects.find(f => f === childSObject)) {
    //     if (childRelationshipName) {
    //       typeContents += `\n  ${childRelationshipName}: ChildRecords<${childSObject}, '${childSObject}'>;`;
    //     } else {
    //       if (child['junctionReferenceTo'].length > 0) {
    //         child['junctionReferenceTo'].forEach(j => {
    //           typeContents += `\n ${j}: ChildRecords<${childSObject}, '${childSObject}'>;`;
    //         });
    //       } else {
    //         if (specialChildrenToMapClone) {
    //           const index = specialChildrenToMapClone.findIndex(f => f === childSObject);
    //           if (index > 0) {
    //             specialChildrenToMapClone.splice(index, 1);
    //             typeContents += `\n  ${childSObject}: ${childSObject};`;
    //           }
    //         }
    //       }
    //     }
    //   } else if (childRelationshipName) {
    //     this.unmappedChildRelationships.add(childSObject);
    //     typeContents += `\n  ${childRelationshipName}: ChildRecords<${childSObject}, '${childSObject}'>;`;
    //   } else if (!childRelationshipName) {
    //     // if(specialChildrenToMap && specialChildrenToMap.find(f=> f === childSObject)){
    //     //   typeContents += `\n  ${childSObject}: ${childSObject};`;
    //     // }
    //   }
    // });

    // add constructor
    typeContents += '\n' + constructor(objectName);

    // overrides getAllFields() method
    // typeContents += this.generateGetAllFieldsMethod(sObjectConf.fields, soupLocalFields);

    typeContents += `\n  getAllFields() {\n    return [...super.getAllFields(), ...${objectName}.sObjectOwnFields, ...${objectName}.sObjectLocalFields];\n  }\n`;

    if (sObjectConf.createFields) {
      typeContents += '\n' + this.generateFieldsList('Create', sObjectConf.createFields);
    } else {
      typeContents += `\n  getCreateFields() {\n    return [...${objectName}.sObjectOwnFields];\n  }\n`;
    }

    if (sObjectConf.updateFields) {
      typeContents += '\n' + this.generateFieldsList('Update', sObjectConf.updateFields);
    }

    typeContents += '}\n'

    // Picklist enums
    typeContents += this.generatePicklists(picklists);

    //record types
    if(describe.recordTypeInfos.length && false) { // disabled
      typeContents += `\n\nexport interface ${objectName}RecordTypes {`;
      describe.recordTypeInfos.forEach(recordType => {
        if (recordType.master) {
          return;
        }
        typeContents += `\n  ${recordType.developerName}: RecordType;`
      });
      typeContents += '\n}'
    }

    return typeContents
  }

  generatePicklists(picklists: {[picklistName: string]: PicklistEntry[]}) {
    const names = Object.keys(picklists);
    if(!names) {
      return '';
    }

    return names.map(picklistName => {
      let enumContent = `\nexport enum ${picklistName} {\n`;
      enumContent += picklists[picklistName].map(entry => `  ${this.formatPropertyName(entry.label || entry.value)} = '${entry.value}'`).join(',\n');
      enumContent += '\n}';
      return enumContent
    }).join('\n');
  }

  getSoupLocalFields(fields: string[], sObjectFields: string[]) {
    if(!fields || !fields.length) {
      return [];
    }

    return fields.filter(field => !sObjectFields.includes(field));
  }

  generateGetAllFieldsMethod(allFields: string[], parentFields: string[]) {
    if(parentFields.length) {

    }
    const filteredFields = parentFields.length ? allFields.filter(fieldName => !parentFields.includes(fieldName)) : allFields;
    let methodContent = '';
    const fieldsStr = filteredFields.map(field => `'${field}'`).join(', ');
    methodContent +=`\n  getAllFields() {`;
    methodContent +=`\n    const parentFields = [${fieldsStr}];`;
    methodContent +=`\n    return super.getAllFields().filter(fieldName => !parentFields.includes(fieldName));`;
    methodContent +=`\n  }\n`;

    return methodContent;
  }

  generateFileHeader = () => {
    let typeContents = [header + '\n'];
    typeContents.push(`/* tslint:disable:max-line-length */`);
    typeContents.push(`/* tslint:disable:variable-name */`);
    typeContents.push(`/* tslint:disable:class-name */`);
    typeContents.push(`import { SObjectBase } from '../soup-local/s-object-base';`);
    typeContents.push(`import { LayerObject } from '../soup-local/layer-object';`);
    typeContents.push(`import { ID, DateString, PhoneString, PercentString } from './sobject-field-types';`);

    return typeContents.join('\n');
  }

  generateSObject = async () => {
    const objectName: string = this.flags.sobject;
    let typeContents = this.generateFileHeader();
    const pascalObjectName = objectName.replace('__c', '').replace('_', '');
    typeContents += await this.generateSObjectTypeContents(objectName)
    let filePath = join(this.flags.outputdir, `${pascalObjectName.toLowerCase()}.ts`);

    await core.fs.writeFile(filePath, typeContents);
    this.createdFiles.push(filePath);
  }

  generateSObjectKeyToType(sobjects: SobjectConfigurations) {
    let typeContents = `\n\n// key map to types:`;
    typeContents += `\nexport interface KeyMapSObjects {`
    for (const s of Object.keys(sobjects)) {
      typeContents += `\n  ${s}: ${s}`;
    }
    typeContents += `\n}`
    return typeContents;
  }

  generateSObjectsMapEnum(sobjects: SobjectConfigurations) {
    let typeContents = `\n\n// sObjects map`;
    typeContents += `\nexport const SObjectsMap = {`
    for (const s of Object.keys(sobjects)) {
      typeContents += `\n  ${s},`;
    }
    typeContents += `\n}`
    return typeContents;
  }

  private async generateSObjectsConfig() {
    let conn = this.org.getConnection();
    let typeContents = this.generateFileHeader();
    const {sobjects, specialChildrenToMap, globalPicklistFields} = await this.readFile();
    const promises: Array<Promise<string | void>> = [];

    for (const key of Object.keys(sobjects)) {
      this.ux.log(`Processing... ${key}`);
      promises.push(this.generateSObjectTypeContents(key, sobjects, globalPicklistFields));
    }

    this.ux.log(`Writing to file...`);
    await Promise.all(promises); // hack to get consistent file order
    promises.forEach(p => {
      p.then(result => {
        typeContents += result;
      });
    })
    await Promise.all(promises);

    if(this.unmappedChildRelationships.size) {
      typeContents += `\n// unmapped types:`;
      Array.from(this.unmappedChildRelationships).sort().forEach(unmappedType => {
        typeContents += `\ntype ${unmappedType} = any; `;
      });
    }

    typeContents += this.generateSObjectKeyToType(sobjects);
    typeContents += this.generateSObjectsMapEnum(sobjects);
    typeContents += '\n\nexport type SObjectName = keyof KeyMapSObjects;';

    if(Object.keys(this.globalPicklists).length) {
      typeContents += '\n\n';
      typeContents += '// global picklists';
      typeContents += this.generatePicklists(this.globalPicklists);
    }
    typeContents += '\n';

    let filePath = join(this.flags.outputdir, `sobjects.entity.ts`);

    await core.fs.writeFile(filePath, typeContents);
    this.createdFiles.push(filePath);
  }

  generateFieldsList(type: 'Create' | 'Update' | 'Delete', fields: string[]) {
    return `  get${type}Fields() {\n    return [${fields.map(fieldName => `'${fieldName}'`).join(', ')}]\n  }\n`;
  }

  generateSObjectNameType(sobjects: SobjectConfigurations): string {
    const sObjectsNamesList = Object.keys(sobjects).sort();
    if(!sObjectsNamesList || !sObjectsNamesList.length) {
      return '';
    }

    return '\n\nexport type SObjectName = ' + sObjectsNamesList.map(name => `'${name}'`).join(' | ') + ';';
  }


  /**
   * Returns configuration object
   */
  async readFile(): Promise<Configuration> {
    const buffer = await core.fs.readFile(this.flags.config);
    let json = buffer.toString('utf8');
    let jsonParsed: Configuration;
    try {
      jsonParsed = JSON.parse(json);
    } catch (ex) {
      process.stderr.write(`FAILED TO PARSE JSON: '${this.flags.config}'\n`);
      if (ex instanceof Error) {
        process.stderr.write(`${ex.stack}\n`);
      } else {
        process.stderr.write(`Error: ${ex}`);
      }
      throw ex;
    }
    return jsonParsed;
  }

  private formatPropertyName(name: any) {
    name = name
      .replace(/\W/g, '_') // replace all non-word character to _
      .replace(/^_+|_+$/g, '') // remove _ symbol from start and end
      .replace(/__+/g, '_') // remove duplicates of _
      .toUpperCase();

    return isNaN(name) ? name : `'${name}'`;
  }

  private formatFieldName(fieldString) {
    const matches = fieldString.match(/^toLabel\((?<field>.*)\)\s*(?<alias>\w*)$/);
    if (matches && matches.groups.field) {
      if(!matches.groups.alias) {
        return matches.groups.field;
      } else if (!matches.groups.field.includes('.')) {
        return matches.groups.alias;
      }

      const fieldParts = matches.groups.field.split('.');
      fieldParts[fieldParts.length - 1] = matches.groups.alias;

      return fieldParts.join('.');
    }

    return fieldString;
  }

  // private formatFieldName(fieldString, fields: string[]): {name: string, type: string} {
  //   const result = {
  //     name: '',
  //     type: 'any'
  //   };
  //   let fieldParts;
  //   const matches = fieldString.match(/^toLabel\((?<field>.*)\)\s*(?<alias>\w*)$/);
  //   if (matches && matches.groups.field) {
  //     if(!matches.groups.alias) {
  //       return {...result, name: matches.groups.field};
  //     } else if (!matches.groups.field.includes('.')) {
  //       return {...result, name: matches.groups.alias};
  //     }
  //
  //     fieldParts = matches.groups.field.split('.');
  //     fieldParts[fieldParts.length - 1] = matches.groups.alias;
  //
  //   } else if(fieldString.includes('.')) {
  //     fieldParts = fieldString.split('.');
  //   } else {
  //     return {...result, name: fieldString};
  //   }
  //
  //   const setType = (parts: string[]) => {
  //     return `{${parts.shift()}: ${parts.length ? setType(parts) : 'any'}}`
  //   };
  //   result.name = fieldParts.shift();
  //   result.type = setType(fieldParts);
  //
  //   return result;
  // }

  private generateSoupLocalFields(fields: string[]) {
    const getObject = (parts: string[]) => {
      return {[parts.shift()]: parts.length ? getObject(parts) : 'any'}
    };

    const getType = (val: object | string) => {
      if(typeof val === 'string') {
        return val;
      }
      return '{' + Object.keys(val).map(key => (`${key}: ${getType(val[key])}`)).join(', ') + '}'
    };

    const data = fields.reduce((acc, field) => {
      const fieldParts = field.split('.');
      return mergeDeep(acc, getObject(fieldParts));
    }, {});

    let title = '\n\n  /* Soup local fields */';
    return title + Object.keys(data).reduce((res, field) => (`${res}\n  ${field}: ${getType(data[field])};`), '');
  }
}

interface Configuration {
  sobjects: SobjectConfigurations,
  specialChildrenToMap: Array<string>,
  globalPicklistFields: string[];
}
type SobjectConfigurations = {[sObjectName: string]: SobjectConfig};

interface SobjectConfig {
  fields: string[];
  createFields: string[];
  updateFields: string[];
  picklistFields?:  string[];
}


/**
 * TODO: Move to utils
 * Simple object check.
 * @param item
 * @returns {boolean}
 */
export function isObject(item) {
  return (item && typeof item === 'object' && !Array.isArray(item));
}

/**
 * TODO: Move to utils
 * Deep merge two objects.
 */
export function mergeDeep(target, ...sources) {
  if (!sources.length) return target;
  const source = sources.shift();

  if (isObject(target) && isObject(source)) {
    for (const key in source) {
      if (isObject(source[key])) {
        if (!target[key]) Object.assign(target, { [key]: {} });
        mergeDeep(target[key], source[key]);
      } else {
        Object.assign(target, { [key]: source[key] });
      }
    }
  }

  return mergeDeep(target, ...sources);
}
