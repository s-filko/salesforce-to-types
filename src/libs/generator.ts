import { core } from '@salesforce/command';
import { OutputFlags } from '@oclif/parser';
import { join } from 'path';
import { Org, UX } from '@salesforce/core';


const header = `
/**
 * DO NOT MODIFY THIS FILE!
 *
 * This file is generated by the salesforce-to-types plugin and
 * may be regenerated in the future. It is recommended to make
 * changes to that plugin then regenerate these files.
 *
 */
`.trim();

const sobject = `${header}

import { ID, Attribute } from './sobject-field-types';

export type SObjectAttribute<TString> = SObject & Attribute<TString>;
export interface SObject {
  Id: ID;
}
`;

const constructor = `
  constructor(data = {}) {
    super();
    super.setValues(data);
  }
`;


const sobjectFieldTypes = `${header}

export type ID = string;
export type DateString = string | null;
export type PhoneString = string;
export type PercentString = string | number;
export type Attribute<TString> = { attributes: { type: TString } }
export type ChildRecords<T, TString> = { records: Array<Partial<T> & Attribute<TString>> };
\/\/ export type RecordType = { Id: string; Name: string; DeveloperName: string; };
`;

export class Generator {
  flags: OutputFlags<any>;
  createdFiles: Array<String> = [];
  globalPicklists: {[picklistName: string]: string[]} = {};
  unmappedChildRelationships: Set<String>;
  org: Org
  ux: UX

  constructor(params: { org, flags, createdFiles?, ux }) {
    this.org = params.org;
    this.ux = params.ux;
    this.flags = params.flags;
    this.createdFiles = params.createdFiles || this.createdFiles;
    this.unmappedChildRelationships = new Set<String>();
  }


  public async generate() {
    await this.createBaseSObjectType();
    await this.createSalesforceFieldTypes();
    if (this.flags.sobject && this.flags.config) {
      process.stderr.write(`Please provide only -s or -c, not both`);
    } else if (this.flags.sobject) {
      await this.generateSObject();
    } else if (this.flags.config) {
      await this.generateSObjectsConfig()
    } else {
      process.stderr.write(`Please provide a -s or -c`);
    }
    return {createdFiles: this.createdFiles || []}
  }

  private async createBaseSObjectType() {
    const dir = await core.fs.readdir(this.flags.outputdir);
    const filePath = join(this.flags.outputdir, 'sobject.ts');
    await core.fs.writeFile(filePath, sobject);
    this.createdFiles.push(filePath);
  }

  private async createSalesforceFieldTypes() {
    const dir = await core.fs.readdir(this.flags.outputdir);
    const filePath = join(this.flags.outputdir, 'sobject-field-types.ts');
    await core.fs.writeFile(filePath, sobjectFieldTypes);
    this.createdFiles.push(filePath);
    return
  }

  generateSObjectTypeContents = async (objectName: string, sObjectsConfigs?: SobjectConfigurations, globalPicklistFields: string[] = []) => {
    let connection = this.org.getConnection();
    const describe = await connection.describe(objectName);
    const sObjects = Object.keys(sObjectsConfigs);
    const sObjectConf = sObjectsConfigs[objectName];
    let typeContents = '\n\n';
    const picklists: {[picklistName: string]: string[]} = {};

    const isFieldIgnored = (fieldName) => sObjectConf.fields && !sObjectConf.fields.includes(fieldName)

    typeContents += `export class ${objectName} extends SObjectBase<'${objectName}'> implements LayerObject {`;

    typeContents += `\n  static sObjectFields = [${sObjectConf.fields.map(f => `'${f}'`).join(', ')}];\n`;

    // const specialChildrenToMapClone = Array.from(specialChildrenToMap || []);
    describe.fields.forEach(field => {
      if (field['name'] == 'Id' || isFieldIgnored(field['name']) ) {
        return;
      }

      let typeName: string;
      switch (field['type']) {
        case 'boolean':
          typeName = 'boolean';
          break;
        case 'int':
        case 'double':
        case 'currency':
          typeName = 'number';
          break;
        case 'date':
        case 'datetime':
          typeName = 'DateString | null';
          break;
        case 'phone':
          typeName = 'PhoneString';
          break;
        case 'string':
        case 'textarea':
          typeName = 'string';
          break;
        case 'reference':
          typeName = 'ID';
          break;
        case 'percent':
          typeName = 'PercentString';
          break;
        default:
          typeName = `string /* ${field['type']} */`;
      }

      if (field['type'] == 'picklist' && field.picklistValues.length) {
        const isCreateEnum = sObjectConf.picklistFields && sObjectConf.picklistFields.length && sObjectConf.picklistFields.includes(field.name);
        const isCreateGlobalEnum = globalPicklistFields.length && globalPicklistFields.includes(field.name);

        if(isCreateGlobalEnum && !this.globalPicklists.hasOwnProperty(field.name)) { // Add and use first picklist value
          this.globalPicklists[field.name] = field.picklistValues.map(p => p.value);
        }

        if(isCreateEnum) {
          typeName = objectName + field.name;
          picklists[typeName] = field.picklistValues.map(p => p.value);
        } else if(isCreateGlobalEnum) {
          typeName = typeName || field.name;
        } else {
          typeName = field.picklistValues.map(p => `"${p.value}"`).join(' | ')
        }
      }

      typeContents += `\n  ${field['name']}: ${typeName};`;

      if (field['calculated']) {
        typeContents += ` // calculated`;
      }

      // REFERENCES
      // if (field['type'] == 'reference') {
      //   let refTypeName;
      //   field.referenceTo.forEach(r => {
      //     if (sObjects && sObjects.find(f => f === r)) {
      //       //add it if its in our list
      //       refTypeName = refTypeName ? `${refTypeName} | ${r}` : r
      //     }
      //   });
      //   if (refTypeName) {
      //     typeContents += `\n  ${field['relationshipName']}: ${refTypeName};`;
      //   }
      // }
    });

    const soupLocalFields = this.getSoupLocalFields(sObjectConf.fields, describe.fields.map(field => field.name));
    if(soupLocalFields.length) {
      typeContents += '\n\n  /* Soup local fields */';
      typeContents += '\n  ' + soupLocalFields.map(fieldName => `['${fieldName}'] = undefined;`).join('\n  ');
    }

    //child relationships
    // describe.childRelationships.forEach(child => {
    //   const childSObject = child['childSObject'];
    //   const childRelationshipName = child['relationshipName'];
    //   if (sObjects && sObjects.find(f => f === childSObject)) {
    //     if (childRelationshipName) {
    //       typeContents += `\n  ${childRelationshipName}: ChildRecords<${childSObject}, '${childSObject}'>;`;
    //     } else {
    //       if (child['junctionReferenceTo'].length > 0) {
    //         child['junctionReferenceTo'].forEach(j => {
    //           typeContents += `\n ${j}: ChildRecords<${childSObject}, '${childSObject}'>;`;
    //         });
    //       } else {
    //         if (specialChildrenToMapClone) {
    //           const index = specialChildrenToMapClone.findIndex(f => f === childSObject);
    //           if (index > 0) {
    //             specialChildrenToMapClone.splice(index, 1);
    //             typeContents += `\n  ${childSObject}: ${childSObject};`;
    //           }
    //         }
    //       }
    //     }
    //   } else if (childRelationshipName) {
    //     this.unmappedChildRelationships.add(childSObject);
    //     typeContents += `\n  ${childRelationshipName}: ChildRecords<${childSObject}, '${childSObject}'>;`;
    //   } else if (!childRelationshipName) {
    //     // if(specialChildrenToMap && specialChildrenToMap.find(f=> f === childSObject)){
    //     //   typeContents += `\n  ${childSObject}: ${childSObject};`;
    //     // }
    //   }
    // });

    // add constructor
    typeContents += '\n' + constructor;

    // overrides getAllFields() method
    // typeContents += this.generateGetAllFieldsMethod(sObjectConf.fields, soupLocalFields);

    typeContents += `\n  getAllFields() {\n    return [...super.getAllFields(), ...${objectName}.sObjectFields];\n  }\n`;

    if (sObjectConf.createFields) {
      typeContents += '\n' + this.generateFieldsList('Create', sObjectConf.createFields);
    }

    if (sObjectConf.updateFields) {
      typeContents += '\n' + this.generateFieldsList('Update', sObjectConf.updateFields);
    }

    typeContents += '}\n'

    // Picklist enums
    typeContents += this.generatePicklists(picklists);

    //record types
    if(describe.recordTypeInfos.length && false) { // disabled
      typeContents += `\n\nexport interface ${objectName}RecordTypes {`;
      describe.recordTypeInfos.forEach(recordType => {
        if (recordType.master) {
          return;
        }
        typeContents += `\n  ${recordType.developerName}: RecordType;`
      });
      typeContents += '\n}'
    }

    return typeContents
  }

  generatePicklists(picklists: {[picklistName: string]: string[]}) {
    const names = Object.keys(picklists);
    if(!names) {
      return '';
    }

    return names.map(picklistName => {
      let enumContent = `\nexport enum ${picklistName} {\n`;
      enumContent += picklists[picklistName].map(value => `  ${this.formatPropertyName(value)} = '${value}'`).join(',\n');
      enumContent += '\n}';
      return enumContent
    }).join('\n');
  }

  getSoupLocalFields(fields: string[], sObjectFields: string[]) {
    if(!fields || !fields.length) {
      return [];
    }

    return fields.filter(field => !sObjectFields.includes(field));
  }

  generateGetAllFieldsMethod(allFields: string[], parentFields: string[]) {
    if(parentFields.length) {

    }
    const filteredFields = parentFields.length ? allFields.filter(fieldName => !parentFields.includes(fieldName)) : allFields;
    let methodContent = '';
    const fieldsStr = filteredFields.map(field => `'${field}'`).join(', ');
    methodContent +=`\n  getAllFields() {`;
    methodContent +=`\n    const parentFields = [${fieldsStr}];`;
    methodContent +=`\n    return super.getAllFields().filter(fieldName => !parentFields.includes(fieldName));`;
    methodContent +=`\n  }\n`;

    return methodContent;
  }

  generateFileHeader = () => {
    let typeContents = [header + '\n'];
    typeContents.push(`/* tslint:disable:max-line-length */`);
    typeContents.push(`/* tslint:disable:variable-name */`);
    typeContents.push(`/* tslint:disable:class-name */`);
    typeContents.push(`import { SObjectBase } from '../s-object-base';`);
    typeContents.push(`import { LayerObject } from './layer-object';`);
    typeContents.push(`import { ID, DateString, PhoneString, PercentString } from './sobject-field-types';`);

    return typeContents.join('\n');
  }

  generateSObject = async () => {
    const objectName: string = this.flags.sobject;
    let typeContents = this.generateFileHeader();
    const pascalObjectName = objectName.replace('__c', '').replace('_', '');
    typeContents = await this.generateSObjectTypeContents(objectName)
    let filePath = join(this.flags.outputdir, `${pascalObjectName.toLowerCase()}.ts`);

    await core.fs.writeFile(filePath, typeContents);
    this.createdFiles.push(filePath);
  }

  generateSObjectKeyToType(sobjects: SobjectConfigurations) {
    let typeContents = `\n\n// key map to types:`;
    typeContents += `\nexport interface KeyMapSObjects {`
    for (const s of Object.keys(sobjects)) {
      typeContents += `\n  ${s}: ${s}`;
    }
    typeContents += `\n}`
    return typeContents;
  }

  generateSObjectsMapEnum(sobjects: SobjectConfigurations) {
    let typeContents = `\n\n// sObjects map`;
    typeContents += `\nexport const SObjectsMap = {`
    for (const s of Object.keys(sobjects)) {
      typeContents += `\n  ${s},`;
    }
    typeContents += `\n}`
    return typeContents;
  }

  private async generateSObjectsConfig() {
    let conn = this.org.getConnection();
    let typeContents = this.generateFileHeader();
    const {sobjects, specialChildrenToMap, globalPicklistFields} = await this.readFile();
    const promises: Array<Promise<string | void>> = [];

    for (const key of Object.keys(sobjects)) {
      this.ux.log(`Processing... ${key}`);
      promises.push(this.generateSObjectTypeContents(key, sobjects, globalPicklistFields));
    }

    this.ux.log(`Writing to file...`);
    await Promise.all(promises); // hack to get consistent file order
    promises.forEach(p => {
      p.then(result => {
        typeContents += result;
      });
    })
    await Promise.all(promises);

    if(this.unmappedChildRelationships.size) {
      typeContents += `\n// unmapped types:`;
      Array.from(this.unmappedChildRelationships).sort().forEach(unmappedType => {
        typeContents += `\ntype ${unmappedType} = any; `;
      });
    }

    typeContents += this.generateSObjectKeyToType(sobjects);
    typeContents += this.generateSObjectsMapEnum(sobjects);
    typeContents += '\n\nexport type SObjectName = keyof KeyMapSObjects;';

    if(Object.keys(this.globalPicklists).length) {
      typeContents += '\n\n';
      typeContents += '// global picklists';
      typeContents += this.generatePicklists(this.globalPicklists);
    }
    typeContents += '\n';

    let filePath = join(this.flags.outputdir, `sobjects.entity.ts`);

    await core.fs.writeFile(filePath, typeContents);
    this.createdFiles.push(filePath);
  }

  generateFieldsList(type: 'Create' | 'Update' | 'Delete', fields: string[]) {
    return `  get${type}Fields() {\n    return [${fields.map(fieldName => `'${fieldName}'`).join(', ')}]\n  }\n`;
  }

  generateSObjectNameType(sobjects: SobjectConfigurations): string {
    const sObjectsNamesList = Object.keys(sobjects).sort();
    if(!sObjectsNamesList || !sObjectsNamesList.length) {
      return '';
    }

    return '\n\nexport type SObjectName = ' + sObjectsNamesList.map(name => `'${name}'`).join(' | ') + ';';
  }


  /**
   * Returns configuration object
   */
  async readFile(): Promise<Configuration> {
    const buffer = await core.fs.readFile(this.flags.config);
    let json = buffer.toString('utf8');
    let jsonParsed: Configuration;
    try {
      jsonParsed = JSON.parse(json);
    } catch (ex) {
      process.stderr.write(`FAILED TO PARSE JSON: '${this.flags.config}'\n`);
      if (ex instanceof Error) {
        process.stderr.write(`${ex.stack}\n`);
      } else {
        process.stderr.write(`Error: ${ex}`);
      }
      throw ex;
    }
    return jsonParsed;
  }

  private formatPropertyName(name: string) {
    return name.replace(/\s|-/g, '_').toUpperCase()
  }
}

interface Configuration {
  sobjects: SobjectConfigurations,
  specialChildrenToMap: Array<string>,
  globalPicklistFields: string[];
}
type SobjectConfigurations = {[sObjectName: string]: SobjectConfig};

interface SobjectConfig {
  fields: string[];
  createFields: string[];
  updateFields: string[];
  picklistFields?:  string[];
}
